diff --git a/in/ac/iitd/src/main/java/index/bplusTree/BPlusTreeIndexFile.java b/in/ac/iitd/src/main/java/index/bplusTree/BPlusTreeIndexFile.java
index 4d23ef0..16024b5 100644
--- a/in/ac/iitd/src/main/java/index/bplusTree/BPlusTreeIndexFile.java
+++ b/in/ac/iitd/src/main/java/index/bplusTree/BPlusTreeIndexFile.java
@@ -2,6 +2,7 @@ package index.bplusTree;
 
 import storage.AbstractFile;
 
+import java.util.List;
 import java.util.Queue;
 
 import java.util.ArrayList;
@@ -52,13 +53,13 @@ public class BPlusTreeIndexFile<T> extends AbstractFile<BlockNode> {
     private int getRootId() {
         BlockNode node = blocks.get(0);
         byte[] rootBlockIdBytes = node.get_data(2, 2);
-        return (rootBlockIdBytes[0] << 8) | (rootBlockIdBytes[1] & 0xFF);
+        return ((rootBlockIdBytes[0] << 8)) | (rootBlockIdBytes[1] & 0xFF);
     }
 
     public int getOrder() {
         BlockNode node = blocks.get(0);
         byte[] orderBytes = node.get_data(0, 2);
-        return (orderBytes[0] << 8) | (orderBytes[1] & 0xFF);
+        return ((orderBytes[0] << 8)) | (orderBytes[1] & 0xFF);
     }
 
     private boolean isLeaf(BlockNode node){
@@ -69,19 +70,257 @@ public class BPlusTreeIndexFile<T> extends AbstractFile<BlockNode> {
         return isLeaf(blocks.get(id));
     }
 
+    private int comparator(T key1, T key2) {
+        if (key1 instanceof Integer && key2 instanceof Integer) {
+            return Integer.compare((Integer) key1, (Integer) key2);
+        }
+        else if (key1 instanceof String && key2 instanceof String) {
+            return ((String) key1).compareTo((String) key2);
+        }
+        else if (key1 instanceof Boolean && key2 instanceof Boolean) {
+            return Boolean.compare((Boolean) key1, (Boolean) key2);
+        }
+        else if (key1 instanceof Float && key2 instanceof Float) {
+            return Float.compare((Float) key1, (Float) key2);
+        }
+        else if (key1 instanceof Double && key2 instanceof Double) {
+            return Double.compare((Double) key1, (Double) key2);
+        }
+        else {
+            throw new IllegalArgumentException("Unsupported key types");
+        }
+    }
+
+
     // will be evaluated
     public void insert(T key, int block_id) {
 
         /* Write your code here */
+
+        // initialize the parent array
+        ArrayList<Integer> parent = new ArrayList<>();
+
+        // find the leaf node to which key should be inserted
+        int id = getRootId();
+        while(!isLeaf(id)){
+            parent.add(id);
+            id = ((InternalNode<T>) blocks.get(id)).search(key);
+        }
+
+        if(!isFull(id)){
+            ((LeafNode<T>) blocks.get(id)).insert(key, block_id);
+        }
+        else{
+            LeafNode<T> left = ((LeafNode<T>) blocks.get(id));
+            int left_id = id;
+            T[] keys = left.getKeys();
+            int[] blockIds = left.getBlockIds();
+            int[] lenKeys = left.getLenKeys();
+
+            List<T> new_keys = new ArrayList<>();
+            List<Integer> new_blockIds = new ArrayList<>();
+
+            LeafNode<T> right = new LeafNode<>(this.typeClass);
+            int right_id = blocks.size();
+            blocks.add(right);
+
+            int nKeys = keys.length;
+            int split = (nKeys+1)/2;
+
+            // find index where new node will be inserted
+            int idx = nKeys;
+            for(int i = 0; i < nKeys; i++){
+                if(comparator(keys[i], key) > 0){
+                    idx = i;
+                    break;
+                }
+            }
+
+            // write new data into new_keys and new_blocks
+            for(int i = 0; i < idx; i++){
+                new_keys.add(keys[i]);
+                new_blockIds.add(blockIds[i]);
+            }
+
+            new_keys.add(key);
+            new_blockIds.add(block_id);
+
+            for(int i = idx; i < nKeys; i++){
+                new_keys.add(keys[i]);
+                new_blockIds.add(blockIds[i]);
+            }
+
+            // update length of p
+            byte[] wrt_sz = new byte[2];
+            wrt_sz[0] = (byte) (0 >> 8);
+            wrt_sz[1] = (byte) (0);
+            left.write_data(0, wrt_sz);
+
+            // calculate new last offset for p
+            int offs1 = 8;
+
+            // update new last offset for p
+            byte[] offs1_byte = new byte[2];
+            offs1_byte[0] = (byte) (offs1 >> 8);
+            offs1_byte[1] = (byte) (offs1);;
+            left.write_data(6, offs1_byte);
+
+            for(int i = 0; i < split; i++){
+                left.insert(new_keys.get(i), new_blockIds.get(i));
+            }
+
+            // store next pointer of p and update next pointer of p
+            byte[] old_point = left.get_data(4, 2);
+
+            byte[] next_q = new byte[2];
+            next_q[0] = (byte) (right_id >> 8);
+            next_q[1] = (byte) (right_id);
+            left.write_data(4, next_q);
+
+            //  write remaining keys to q it will automatically update length and last offset
+            for(int i = split; i < new_keys.size(); i++){
+                right.insert(new_keys.get(i), new_blockIds.get(i));
+            }
+
+            // update prev and next pointer for q
+            byte[] p_id = new byte[2];
+            p_id[0] = (byte) (left_id >> 8);
+            p_id[1] = (byte) (left_id);
+            right.write_data(2, p_id);
+
+            right.write_data(4, old_point);
+
+            // update prev of next of p
+            int old_id = ((old_point[0] << 8)) | (old_point[1] & 0xFF);
+            if(old_id != 0){
+                LeafNode<T> old_leaf = (LeafNode<T>) blocks.get(old_id);
+                old_leaf.write_data(2, next_q);
+            }
+
+            insert_internal(new_keys.get(split), left_id, right_id, parent, parent.size()-1);
+
+        }
         return;
     }
 
+    public void insert_internal(T key, int left_block_id, int right_block_id, ArrayList<Integer> parent, int index){
+        if(left_block_id == getRootId()){
+//            System.out.println("boo");
+            // just create a single Node with entry l key r
+            InternalNode<T> new_root = new InternalNode<>(key,left_block_id,right_block_id,this.typeClass);
+            byte[] rootNodeIdBytes = new byte[2];
+            int blk_sz = blocks.size();
+//            System.out.println("new root block: "+blk_sz);
+//            System.out.println("right block: "+right_block_id);
+            rootNodeIdBytes[0] = (byte) (blk_sz >> 8);
+            rootNodeIdBytes[1] = (byte) (blk_sz);
+
+            blocks.get(0).write_data(2, rootNodeIdBytes);
+            blocks.add(new_root);
+//            System.out.println(getRootId());
+            return;
+        }
+
+        InternalNode<T> p = ((InternalNode<T>) blocks.get(parent.get(index)));
+        if(!isFull(parent.get(index))){
+            p.insert(key, right_block_id);
+        }
+        else{
+            T[] keys = p.getKeys();
+            int[] blockIds = p.getChildren();
+            int[] lenKeys = p.getLenK();
+
+            int nKeys = keys.length;
+            int split = (nKeys+1)/2;
+
+            List<T> new_keys = new ArrayList<>();g
+            List<Integer> new_blockIds = new ArrayList<>();
+
+            // find index where new node will be inserted
+            int idx = nKeys;
+            for(int i = 0; i < nKeys; i++){
+                if(comparator(keys[i], key) > 0){
+                    idx = i;
+                    break;
+                }
+            }
+
+            // write new data into new_keys and new_blocks
+            new_blockIds.add(blockIds[0]);
+            for(int i = 0; i < idx; i++){
+                new_keys.add(keys[i]);
+                new_blockIds.add(blockIds[i+1]);
+            }
+
+            new_keys.add(key);
+            new_blockIds.add(right_block_id);
+
+            for(int i = idx; i < nKeys; i++){
+                new_keys.add(keys[i]);
+                new_blockIds.add(blockIds[i+1]);
+            }
+
+            // create new right node
+            InternalNode<T> q = new InternalNode<>(new_blockIds.get(split+1),this.typeClass);
+            int q_id = blocks.size();
+            blocks.add(q);
+
+            // update length of p
+            byte[] wrt_sz = new byte[2];
+            wrt_sz[0] = (byte) (0 >> 8);
+            wrt_sz[1] = (byte) (0);
+            p.write_data(0, wrt_sz);
+
+            // calculate new last offset for p
+            int offs1 = 6;
+
+            // update new last offset for p
+            byte[] offs1_byte = new byte[2];
+            offs1_byte[0] = (byte) (offs1 >> 8);
+            offs1_byte[1] = (byte) (offs1);;
+            p.write_data(2, offs1_byte);
+
+            // write to p
+            for(int i = 0; i < split; i++){
+                p.insert(new_keys.get(i), new_blockIds.get(i+1));
+            }
+
+            //  write remaining keys to q it will automatically update length and last offset of q
+            for(int i = split+1; i < new_keys.size(); i++){
+                q.insert(new_keys.get(i), new_blockIds.get(i+1));
+            }
+
+            // finally recursively call insert_internal for p, keys[p_sz], q
+            insert_internal(new_keys.get(split), parent.get(index), q_id, parent, index-1);
+        }
+    }
+
+
     // will be evaluated
     // returns the block_id of the leftmost leaf node containing the key
     public int search(T key) {
 
         /* Write your code here */
-        return -1;
+        int id = getRootId();
+        while(!isLeaf(id)){
+            id = ((InternalNode<T>) blocks.get(id)).search(key);
+        }
+//        return id;
+
+        if(((LeafNode<T>) blocks.get(id)).search(key) == -1) return id;
+        else{
+            LeafNode<T> l = (LeafNode<T>) blocks.get(id);
+            while (id != 0){
+                byte[] temp = l.get_data(2, 2);
+
+                int prev = ((temp[0] << 8)) | (temp[1] & 0xFF);
+                if(prev == 0 || ((LeafNode<T>) blocks.get(prev)).search(key) == -1) break;
+
+                id = prev;
+                l = (LeafNode<T>) blocks.get(id);
+            }
+            return id;
+        }
     }
 
     // returns true if the key was found and deleted, false otherwise
@@ -141,9 +380,39 @@ public class BPlusTreeIndexFile<T> extends AbstractFile<BlockNode> {
         return bfs;
     }
 
+    public void prt_bfs() {
+        System.out.println();
+        int root = getRootId();
+        Queue<Integer> queue = new LinkedList<>();
+//        ArrayList<T> bfs = new ArrayList<>();
+        queue.add(root);
+        while(!queue.isEmpty()) {
+            int id = queue.remove();
+            if(isLeaf(id)) {
+                T[] keys = ((LeafNode<T>) blocks.get(id)).getKeys();
+                for(int i = 0; i < keys.length; i++) {
+//                    bfs.add((T) keys[i]);
+                    System.out.print(keys[i] + " ");
+                }
+            }
+            else {
+                T[] keys = ((InternalNode<T>) blocks.get(id)).getKeys();
+                for(int i = 0; i < keys.length; i++) {
+//                    bfs.add((T) keys[i]);
+                    System.out.print(keys[i] + " ");
+                }
+                int[] children = ((InternalNode<T>) blocks.get(id)).getChildren();
+                for(int i = 0; i < children.length; i++) {
+                    queue.add(children[i]);
+                }
+            }
+            System.out.println();
+        }
+    }
+
     public void print() {
         print_bfs();
         return;
     }
 
-}
\ No newline at end of file
+}
diff --git a/in/ac/iitd/src/main/java/index/bplusTree/InternalNode.java b/in/ac/iitd/src/main/java/index/bplusTree/InternalNode.java
index 2217aec..231e758 100644
--- a/in/ac/iitd/src/main/java/index/bplusTree/InternalNode.java
+++ b/in/ac/iitd/src/main/java/index/bplusTree/InternalNode.java
@@ -13,9 +13,9 @@ public class InternalNode<T> extends BlockNode implements TreeNode<T> {
 
     // Constructor - expects the key, left and right child ids
     public InternalNode(T key, int left_child_id, int right_child_id, Class<T> typeClass) {
-
         super();
         this.typeClass = typeClass;
+//        System.out.println("fasuioerfneiufn");
 
         byte[] numKeysBytes = new byte[2];
         numKeysBytes[0] = 0;
@@ -24,8 +24,8 @@ public class InternalNode<T> extends BlockNode implements TreeNode<T> {
         this.write_data(0, numKeysBytes);
 
         byte[] child_1 = new byte[2];
-        child_1[0] = (byte) ((left_child_id >> 8) & 0xFF);
-        child_1[1] = (byte) (left_child_id & 0xFF);
+        child_1[0] = (byte) (left_child_id >> 8);
+        child_1[1] = (byte) (left_child_id);
 
         this.write_data(4, child_1);
 
@@ -40,6 +40,32 @@ public class InternalNode<T> extends BlockNode implements TreeNode<T> {
         return;
     }
 
+    public InternalNode(int left_child_id, Class<T> typeClass) {
+
+        super();
+        this.typeClass = typeClass;
+
+        byte[] numKeysBytes = new byte[2];
+        numKeysBytes[0] = 0;
+        numKeysBytes[1] = 0;
+
+        this.write_data(0, numKeysBytes);
+
+        byte[] child_1 = new byte[2];
+        child_1[0] = (byte) (left_child_id >> 8);
+        child_1[1] = (byte) (left_child_id);
+
+        this.write_data(4, child_1);
+
+        byte[] nextFreeOffsetBytes = new byte[2];
+        nextFreeOffsetBytes[0] = 0;
+        nextFreeOffsetBytes[1] = 6;
+
+        this.write_data(2, nextFreeOffsetBytes);
+
+        return;
+    }
+
     // returns the keys in the node - will be evaluated
     @Override
     public T[] getKeys() {
@@ -48,22 +74,155 @@ public class InternalNode<T> extends BlockNode implements TreeNode<T> {
         T[] keys = (T[]) new Object[numKeys];
 
         /* Write your code here */
-
+        int startPos = 4;
+        for (int i = 0; i < numKeys; i++) {
+            startPos += 2;
+            byte[] key_lenByte = this.get_data(startPos, 2);
+            int key_len = ((key_lenByte[0]) << 8) | (key_lenByte[1] & 0xFF);
+            startPos += 2;
+            byte[] key_data = this.get_data(startPos, key_len);
+            keys[i] = convertBytesToT(key_data, typeClass); //doubt
+            startPos += key_len;
+        }
         return keys;
     }
 
+    public int[] getLenK(){
+        int numKeys = getNumKeys();
+        int[] len_keys = new int[numKeys];
+
+        int startPos = 4;
+        for(int i = 0; i < numKeys; i++){
+            startPos += 2;
+            byte[] keyLen = this.get_data(startPos, 2);
+            len_keys[i] = ((keyLen[0]) << 8) | (keyLen[1] & 0xFF);
+            startPos += 2;
+            startPos += len_keys[i];
+        }
+        return len_keys;
+    }
+
+
     // can be used as helper function - won't be evaluated
     @Override
     public void insert(T key, int right_block_id) {
         /* Write your code here */
+//        System.out.println("Search: "+key+" : "+search(key));
+        byte[] key_to_array = convertToByteArray(key);
+        int n = key_to_array.length;
+
+        T[] keys = getKeys();
+        int[] blockIds = getChildren();
+        int[] lenKeys = getLenK();
+
+//        System.out.println("size of keys:" + keys.length);
+//        System.out.print("keys: ");
+//        for(int i = 0; i < keys.length; i++){
+//            System.out.print(keys[i] + " ");
+//        }
+//        System.out.println();
+//        System.out.print("Blockids: ");
+//        for(int i = 0; i < blockIds.length; i++){
+//            System.out.print(blockIds[i] + " ");
+//        }
+//        System.out.println();
+
+        int idx = keys.length;
+        int offs = 4;
+        for(int i = 0; i < keys.length; i++){
+            if(comparator(keys[i], key) > 0){
+                idx = i;
+                break;
+            }
+            offs += lenKeys[i];
+            offs += 4;
+        }
+        offs += 2;
+        // write directly the data using offs variable
+
+        // length
+        byte[] temp2 = new byte[] {(byte) (n >> 8), (byte) n};
+        this.write_data(offs, temp2);
+        offs += 2;
+
+        // data (key)
+        this.write_data(offs, key_to_array);
+        offs += n;
+
+        // block_id
+        byte[] temp = new byte[] {(byte) (right_block_id >> 8), (byte) right_block_id};
+        this.write_data(offs, temp);
+        offs += 2;
+
+        // write remaining blocks
+        for(int i = idx; i < keys.length; i++){
+            // length
+            byte[] temp4 = new byte[] {(byte) (lenKeys[i] >> 8), (byte) lenKeys[i]};
+            this.write_data(offs, temp4);
+            offs += 2;
+
+            // data (key)
+            byte[] temp5 = convertToByteArray(keys[i]);
+            this.write_data(offs, temp5);
+            offs += lenKeys[i];
+
+            // block_id
+            byte[] temp3 = new byte[] {(byte) (blockIds[i+1] >> 8), (byte) blockIds[i+1]};
+            this.write_data(offs, temp3);
+            offs += 2;
+        }
+
+        // write the last block id // Incorrect
+//        byte[] temp6 = new byte[] {(byte) (blockIds[keys.length] >> 8), (byte) blockIds[keys.length]};
+//        this.write_data(offs, temp6);
+//        offs += 2;
+
+        // update last offset pointer
+        byte[] temp7 = new byte[] {(byte) (offs >> 8), (byte) (offs)};
+        this.write_data(2, temp7);
+
+        // update key count
+        byte[] temp8 = this.get_data(0, 2);
+        int sz2 = ((temp8[0]) << 8) | (temp8[1] & 0xFF);
+        sz2 += 1;
+        byte[] temp9 = new byte[] {(byte) (sz2 >> 8), (byte) (sz2)};
+        this.write_data(0, temp9);
+
+//        System.out.println("fisuefnawuifnaeuifnawfiuoaefn");
+
+//        T[] keys2 = getKeys();
+//        int[] blockIds2 = getChildren();
+//        int[] lenKeys2 = getLenK();
+//        System.out.print("keys: ");
+//        for(int i = 0; i < keys2.length; i++){
+//            System.out.print(keys2[i] + " ");
+//        }
+//        System.out.println();
+//        System.out.print("Blockids: ");
+//        for(int i = 0; i < blockIds2.length; i++){
+//            System.out.print(blockIds2[i] + " ");
+//        }
+//        System.out.println();
+
 
+        return;
     }
 
     // can be used as helper function - won't be evaluated
     @Override
     public int search(T key) {
         /* Write your code here */
-        return -1;
+        T[] keys = this.getKeys();
+        int[] children = this.getChildren();
+
+        for (int i = 0; i < keys.length; i++) {
+            if (comparator(keys[i], key) > 0) {        // Doubt
+                return children[i];
+            }
+        }
+
+        // If no such key is found, return the last child
+        return children[keys.length];
     }
 
     // should return the block_ids of the children - will be evaluated
@@ -75,9 +234,22 @@ public class InternalNode<T> extends BlockNode implements TreeNode<T> {
         int[] children = new int[numKeys + 1];
 
         /* Write your code here */
-
+        int startPos = 4;
+        for (int i = 0; i < numKeys+1; i++) {
+            byte[] id_data = this.get_data(startPos, 2);
+            children[i] = ((id_data[0]) << 8) | (id_data[1] & 0xFF);
+
+            startPos += 2;
+            // break if last iteration
+            if(i == numKeys) break;
+
+            // if not last then move offset by key and len
+            byte[] key_lenByte = this.get_data(startPos, 2);
+            int key_len = ((key_lenByte[0]) << 8) | (key_lenByte[1] & 0xFF);
+            startPos += 2;
+            startPos += key_len;
+        }
         return children;
-
     }
-
 }
+
diff --git a/in/ac/iitd/src/main/java/index/bplusTree/LeafNode.java b/in/ac/iitd/src/main/java/index/bplusTree/LeafNode.java
index 2d20b35..b9cbb1f 100644
--- a/in/ac/iitd/src/main/java/index/bplusTree/LeafNode.java
+++ b/in/ac/iitd/src/main/java/index/bplusTree/LeafNode.java
@@ -39,32 +39,154 @@ public class LeafNode<T> extends BlockNode implements TreeNode<T>{
         T[] keys = (T[]) new Object[numKeys];
 
         /* Write your code here */
-
+        int startPos = 8;
+        for (int i = 0; i < numKeys; i++) {
+            startPos += 2;
+            byte[] key_lenByte = this.get_data(startPos, 2);
+            int key_len = ((key_lenByte[0]) << 8) | (key_lenByte[1] & 0xFF);
+            startPos += 2;
+            byte[] key_data = this.get_data(startPos, key_len);
+            keys[i] = convertBytesToT(key_data, typeClass); //doubt
+            startPos += key_len;
+        }
         return keys;
-
     }
 
     // returns the block ids in the node - will be evaluated
     public int[] getBlockIds() {
 
         int numKeys = getNumKeys();
-
         int[] block_ids = new int[numKeys];
 
         /* Write your code here */
-
+        int startPos = 8;
+        for (int i = 0; i < numKeys; i++) {
+            byte[] key_data = this.get_data(startPos, 2);
+            block_ids[i] = ((key_data[0]) << 8) | (key_data[1] & 0xFF);
+
+            startPos += 2;
+
+            byte[] key_lenByte = this.get_data(startPos, 2);
+            int key_len = ((key_lenByte[0]) << 8) | (key_lenByte[1] & 0xFF);
+            startPos += 2;
+            startPos += key_len;
+        }
         return block_ids;
     }
 
+    public int[] getLenKeys(){
+        int numKeys = getNumKeys();
+        int[] len_keys = new int[numKeys];
+
+        int startPos = 8;
+        for(int i = 0; i < numKeys; i++){
+            startPos += 2;
+            byte[] keyLen = this.get_data(startPos, 2);
+            len_keys[i] = ((keyLen[0]) << 8) | (keyLen[1] & 0xFF);
+            startPos += 2;
+            startPos += len_keys[i];
+        }
+        return len_keys;
+    }
+
+
+
     // can be used as helper function - won't be evaluated
     @Override
     public void insert(T key, int block_id) {
-
-
+//        System.out.println("sjkfheasou");
         /* Write your code here */
+//        if(this.search(key) != -1) return;           // Doubt if duplicates allowed then change
+        byte[] key_to_array = convertToByteArray(key);
+        int n = key_to_array.length;
+
+        T[] keys = getKeys();
+//        System.out.println("size of keys:" + keys.length);
+        int[] blockIds = getBlockIds();
+        int[] lenKeys = getLenKeys();
+//        System.out.print("keys: ");
+//        for(int i = 0; i < keys.length; i++){
+//            System.out.print(keys[i] + " ");
+//        }
+//        System.out.println();
+//        System.out.print("Blockids: ");
+//        for(int i = 0; i < blockIds.length; i++){
+//            System.out.print(blockIds[i] + " ");
+//        }
+//        System.out.println();
+        int idx = keys.length;
+        int offs = 8;
+        for(int i = 0; i < keys.length; i++){
+            if(comparator(keys[i], key) > 0){
+                idx = i;
+                break;
+            }
+            offs += lenKeys[i];
+            offs += 4;
+        }
+//        System.out.println("idx "+ idx);
+        // write directly the data using offs variable
+
+        // block_id
+        byte[] temp = new byte[] {(byte) (block_id >> 8), (byte) block_id};
+        this.write_data(offs, temp);
+        offs += 2;
+
+        // length
+        byte[] temp2 = new byte[] {(byte) (n >> 8), (byte) n};
+        this.write_data(offs, temp2);
+        offs += 2;
+
+        // data (key)
+        this.write_data(offs, key_to_array);
+        offs += n;
+
+        for(int i = idx; i < keys.length; i++){
+            // block_id
+            byte[] temp3 = new byte[] {(byte) (blockIds[i] >> 8), (byte) blockIds[i]};
+            this.write_data(offs, temp3);
+            offs += 2;
+
+            // length
+            byte[] temp4 = new byte[] {(byte) (lenKeys[i] >> 8), (byte) lenKeys[i]};
+            this.write_data(offs, temp4);
+            offs += 2;
+
+            // data (key)
+            byte[] temp5 = convertToByteArray(keys[i]);
+            this.write_data(offs, temp5);
+            offs += lenKeys[i];
+        }
+
+        // update pointer to last offset
+        byte[] temp6 = new byte[] {(byte) (offs >> 8), (byte) (offs)};
+        this.write_data(6, temp6);
+
+        // update key count
+        byte[] temp7 = this.get_data(0, 2);
+        int sz2 = ((temp7[0]) << 8) | (temp7[1] & 0xFF);
+        sz2 += 1;
+        byte[] temp8 = new byte[] {(byte) (sz2 >> 8), (byte) (sz2)};
+        this.write_data(0, temp8);
+
+
+//        T[] keys2 = getKeys();
+//        System.out.println("size of keys:" + keys2.length);
+//        int[] blockIds2 = getBlockIds();
+//        int[] lenKeys2 = getLenKeys();
+//        System.out.print("keys: ");
+//        for(int i = 0; i < keys2.length; i++){
+//            System.out.print(keys2[i] + " ");
+//        }
+//        System.out.println();
+//        System.out.print("Blockids: ");
+//        for(int i = 0; i < blockIds2.length; i++){
+//            System.out.print(blockIds2[i] + " ");
+//        }
+//        System.out.println();
+//        System.out.println("hi");
 
         return;
-
     }
 
     // can be used as helper function - won't be evaluated
@@ -72,7 +194,28 @@ public class LeafNode<T> extends BlockNode implements TreeNode<T>{
     public int search(T key) {
 
         /* Write your code here */
-        return -1;
-    }
 
+        T[] keys = getKeys();
+        int[] blockIds = getBlockIds();
+
+//        System.out.print("keys: ");
+//        for(int i = 0; i < keys.length; i++){
+//            System.out.print(keys[i] + " ");
+//        }
+//        System.out.println();
+//        System.out.print("Blockids: ");
+//        for(int i = 0; i < blockIds.length; i++){
+//            System.out.print(blockIds[i] + " ");
+//        }
+//        System.out.println();
+//
+//        System.out.println("key:  " + key);
+        for (int i = 0; i < keys.length; i++) {
+            if (comparator(key, keys[i]) == 0) {
+                return blockIds[i];
+            }
+        }
+        return -1; // Key not found
+    }
 }
+
diff --git a/in/ac/iitd/src/main/java/index/bplusTree/TreeNode.java b/in/ac/iitd/src/main/java/index/bplusTree/TreeNode.java
index 1315e6b..a7cf445 100644
--- a/in/ac/iitd/src/main/java/index/bplusTree/TreeNode.java
+++ b/in/ac/iitd/src/main/java/index/bplusTree/TreeNode.java
@@ -22,7 +22,139 @@ public interface TreeNode <T> {
         
         /* Write your code here */
 
-        return null;
+        if (typeClass == Integer.class) {
+            return convertBytesToInteger(bytes, typeClass);
+        } else if (typeClass == String.class) {
+            return typeClass.cast(new String(bytes));
+        } else if (typeClass == Boolean.class) {
+            return convertBytesToBoolean(bytes, typeClass);
+        } else if (typeClass == Float.class) {
+            return convertBytesToFloat(bytes, typeClass);
+        } else if (typeClass == Double.class) {
+            return convertBytesToDouble(bytes, typeClass);
+        } else {
+            throw new UnsupportedOperationException("Conversion for the specified type is not supported");
+        }
     }
-    
-}
\ No newline at end of file
+
+    default public T convertBytesToInteger(byte[] bytes, Class<T> typeClass) {
+        validateBArrayLength(bytes, 4);
+        return typeClass.cast((bytes[0] << 24) | ((bytes[1] & 0xFF) << 16) | ((bytes[2] & 0xFF) << 8) | (bytes[3] & 0xFF));
+    }
+
+    default public T convertBytesToBoolean(byte[] bytes, Class<T> typeClass) {
+        validateBArrayLength(bytes, 1);
+        return typeClass.cast(bytes[0] != 0);
+    }
+
+    default public T convertBytesToFloat(byte[] bytes, Class<T> typeClass) {
+        validateBArrayLength(bytes, 4);
+        return typeClass.cast(Float.intBitsToFloat(byteArrayToFloat(bytes)));
+    }
+
+    default public T convertBytesToDouble(byte[] bytes, Class<T> typeClass) {
+        validateBArrayLength(bytes, 8);
+        return typeClass.cast(Double.longBitsToDouble(byteArrayToLong(bytes)));
+    }
+
+    default public void validateBArrayLength(byte[] bytes, int expectedLength) {
+        if (bytes.length != expectedLength) {
+            throw new IllegalArgumentException("Byte array length does not match the expected length for conversion");
+        }
+    }
+
+    default public int byteArrayToFloat(byte[] bytes) {
+        return (bytes[0] << 24) | ((bytes[1] & 0xFF) << 16) | ((bytes[2] & 0xFF) << 8) | (bytes[3] & 0xFF);
+    }
+
+    default public long byteArrayToLong(byte[] bytes) {
+        long value = 0;
+        for (int i = 0; i < bytes.length; i++) {
+            value |= ((long) (bytes[i] & 0xFF)) << (8 * (bytes.length-1-i)); //Doubt
+        }
+        return value;
+    }
+
+    default public int comparator(T key1, T key2) {
+        if (key1 instanceof Integer && key2 instanceof Integer) {
+            return Integer.compare((Integer) key1, (Integer) key2);
+        }
+        else if (key1 instanceof String && key2 instanceof String) {
+            return ((String) key1).compareTo((String) key2);
+        }
+        else if (key1 instanceof Boolean && key2 instanceof Boolean) {
+            return Boolean.compare((Boolean) key1, (Boolean) key2);
+        }
+        else if (key1 instanceof Float && key2 instanceof Float) {
+            return Float.compare((Float) key1, (Float) key2);
+        }
+        else if (key1 instanceof Double && key2 instanceof Double) {
+            return Double.compare((Double) key1, (Double) key2);
+        }
+        else {
+            throw new IllegalArgumentException("Unsupported key types");
+        }
+    }
+
+    default public byte[] convertToByteArray(Object value) {
+        if (value instanceof String) {
+            return convertStringToBytes((String) value);
+        }
+        else if (value instanceof Integer) {
+            return convertIntToBytes((Integer) value);
+        }
+        else if (value instanceof Float) {
+            return convertFloatToBytes((Float) value);
+        }
+        else if (value instanceof Double) {
+            return convertDoubleToBytes((Double) value);
+        }
+        else if (value instanceof Boolean) {
+            return convertBooleanToBytes((Boolean) value);
+        }
+        else {
+            throw new IllegalArgumentException("Unsupported data type");
+        }
+    }
+
+    default public byte[] convertStringToBytes(String value) {
+        char[] chars = value.toCharArray();
+        byte[] bytes = new byte[chars.length];
+        for (int i = 0; i < chars.length; i++) {
+            bytes[i] = (byte) chars[i];
+        }
+        return bytes;
+    }
+
+    default public byte[] convertIntToBytes(int value) {
+        return new byte[] {
+                (byte) (value >> 24),
+                (byte) (value >> 16),
+                (byte) (value >> 8),
+                (byte) value
+        };
+    }
+
+    default public byte[] convertFloatToBytes(float value) {
+        return convertIntToBytes(Float.floatToIntBits(value));
+    }
+
+    default public byte[] convertDoubleToBytes(double value) {
+        long longValue = Double.doubleToRawLongBits(value);
+        return new byte[] {
+                (byte) (longValue >> 56),
+                (byte) (longValue >> 48),
+                (byte) (longValue >> 40),
+                (byte) (longValue >> 32),
+                (byte) (longValue >> 24),
+                (byte) (longValue >> 16),
+                (byte) (longValue >> 8),
+                (byte) longValue
+        };
+    }
+
+    default public byte[] convertBooleanToBytes(boolean value) {
+        return new byte[] { (byte) (value ? 1 : 0) };
+    }
+}
+
diff --git a/in/ac/iitd/src/main/java/manager/StorageManager.java b/in/ac/iitd/src/main/java/manager/StorageManager.java
index c1eb28a..ea313bc 100644
--- a/in/ac/iitd/src/main/java/manager/StorageManager.java
+++ b/in/ac/iitd/src/main/java/manager/StorageManager.java
@@ -1,5 +1,7 @@
 package manager;
 
+import com.sun.org.apache.xpath.internal.operations.Bool;
+import index.bplusTree.BPlusTreeIndexFile;
 import storage.DB;
 import storage.File;
 import storage.Block;
@@ -8,9 +10,7 @@ import Utils.CsvRowConverter;
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
-import java.util.HashMap;
-import java.util.List;
-import java.util.ArrayList;
+import java.util.*;
 
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rex.RexLiteral;
@@ -21,8 +21,6 @@ import org.json.simple.JSONObject;
 import org.json.simple.parser.JSONParser;
 import org.json.simple.parser.ParseException;
 
-import java.util.Iterator;
-
 public class StorageManager {
 
     private HashMap<String, Integer> file_to_fileid;
@@ -366,6 +364,10 @@ public class StorageManager {
         return schema;
     }
 
+    public int convert_file_to_id(String table_name){
+        return file_to_fileid.get(table_name);
+    }
+
     // should only read one block at a time
     public byte[] get_data_block(String table_name, int block_id){
         int file_id = file_to_fileid.get(table_name);
@@ -387,18 +389,324 @@ public class StorageManager {
         /* Write your code here */
         // return null if file does not exist, or block_id is invalid
         // return list of records otherwise
-        return null;
+        if(!check_file_exists(table_name) || get_data_block(table_name, block_id) == null){
+            return null;
+        }
+
+        // get the schema block as byte array
+        byte[] schema = get_data_block(table_name, 0);
+
+        // get the number of columns from schema
+        int num_columns = ((schema[1] & 0xFF) << 8) | (schema[0] & 0xFF);
+
+        // initialize the iterator for schema and type array for columns
+        int schema_iterator = 2;
+        int[] type_col = new int[num_columns];
+
+        // iterate over schema to fill type_col also get num of fixed and num of variable length columns
+        int fixed_col = 0;
+        int variable_col = 0;
+
+        for(int i = 0; i < num_columns; i++){
+            int offs = ((schema[schema_iterator+1] & 0xFF) << 8) | (schema[schema_iterator] & 0xFF);
+            type_col[i] = (schema[offs] & 0xFF);
+
+            if(type_col[i] == 0){
+                variable_col++;
+            }
+            else if(type_col[i] == 1){
+                fixed_col++;
+            }
+            else if(type_col[i] == 2){
+                fixed_col++;
+            }
+            else if(type_col[i] == 3){
+                fixed_col++;
+            }
+            else{
+                fixed_col++;
+            }
+
+            schema_iterator += 2;
+        }
+
+        // get the block data now
+        byte[] block_data = get_data_block(table_name, block_id);
+
+        // initialize an empty records list
+        List<Object[]> records = new ArrayList<>();
+
+        // get num of records
+        int num_records = ((block_data[0] & 0xFF) << 8) | (block_data[1] & 0xFF);
+
+        // initialize block iterator
+        int block_iterator = 2;
+
+        for(int i = 0; i < num_records; i++){
+            // get the record iterator
+            int record_iterator = ((block_data[block_iterator] & 0xFF) << 8) | (block_data[block_iterator+1] & 0xFF);
+            block_iterator += 2;
+            int base_record = record_iterator;
+            // initialize the object array for storing the record data
+            Object[] instance = new Object[fixed_col+variable_col];
+
+            // initialize array for storing offset and length of each variable length column
+            int[] var_offs = new int[variable_col];
+            int[] var_lens = new int[variable_col];
+
+            // fill the above tables
+            for(int j = 0; j < variable_col; j++){
+                var_offs[j] = ((block_data[record_iterator+1] & 0xFF) << 8) | (block_data[record_iterator] & 0xFF) + base_record;
+                record_iterator += 2;
+
+                var_lens[j] = ((block_data[record_iterator+1] & 0xFF) << 8) | (block_data[record_iterator] & 0xFF);
+                record_iterator += 2;
+            }
+
+            // get the fixed columns
+            for(int j = 0; j < fixed_col; j++){
+                if(type_col[j] == 1){
+                    instance[j] =
+                            ((block_data[record_iterator+3] & 0xFF) << 24) |
+                            ((block_data[record_iterator+2] & 0xFF) << 16) |
+                            ((block_data[record_iterator+1] & 0xFF) << 8) |
+                            (block_data[record_iterator] & 0xFF);
+
+                    record_iterator += 4;
+                }
+                else if(type_col[j] == 2){
+                    instance[j] = (block_data[record_iterator] & 0xFF);
+                    record_iterator += 1;
+                }
+                else if(type_col[j] == 3){
+                    instance[j] = Float.intBitsToFloat(
+                            ((block_data[record_iterator+3] & 0xFF) << 24) |
+                            ((block_data[record_iterator+2] & 0xFF) << 16) |
+                            ((block_data[record_iterator+1] & 0xFF) << 8) |
+                            (block_data[record_iterator] & 0xFF));
+
+                    record_iterator += 4;
+                }
+                else if(type_col[j] == 4){
+                    instance[j] = Double.longBitsToDouble(
+                            ((long)(block_data[record_iterator+7] & 0xFF) << 56) |
+                            ((long)(block_data[record_iterator+6] & 0xFF) << 48) |
+                            ((long)(block_data[record_iterator+5] & 0xFF) << 40) |
+                            ((long)(block_data[record_iterator+4] & 0xFF) << 32) |
+                            ((long)(block_data[record_iterator+3] & 0xFF) << 24) |
+                            ((long)(block_data[record_iterator+2] & 0xFF) << 16) |
+                            ((long)(block_data[record_iterator+1] & 0xFF) << 8) |
+                            (long)(block_data[record_iterator] & 0xFF));
+
+                    record_iterator += 8;
+                }
+                else{
+                    throw new IllegalArgumentException("How did this happen");
+                }
+            }
+
+            // get the null bitmap
+            boolean[] null_bit_map = new boolean[num_columns];
+            int bit_map_index = 0;
+
+            for(int j=0; j<num_columns; j++){
+                if((block_data[record_iterator] & (1 << (7 - bit_map_index))) != 0){
+                    null_bit_map[j] = true;
+                }
+                bit_map_index++;
+                if(bit_map_index == 8 && j != num_columns-1){
+                    bit_map_index = 0;
+                    record_iterator++;
+                }
+            }
+
+//            // reset the record iterator to the first
+//            if(variable_col > 0) record_iterator = va1r_offs[0];
+
+            // now fill in the variable length column
+            for(int j = fixed_col; j < fixed_col+variable_col; j++){
+                // get the offset to and length of the variable columns
+                int offs = var_offs[j-fixed_col];
+                int lens = var_lens[j-fixed_col];
+
+                byte[] temp = new byte[lens];
+                System.arraycopy(block_data, offs, temp, 0, lens);
+
+                instance[j] = new String(temp);
+            }
+
+            for(int z = 0; z < instance.length; z++){
+                if(null_bit_map[z]){
+                    instance[z] = null;
+                }
+            }
+            records.add(instance);
+        }
+        return records;
     }
 
     public boolean create_index(String table_name, String column_name, int order) {
         /* Write your code here */
-        return false;
+
+        // get the schema block as byte array
+        byte[] schema = get_data_block(table_name, 0);
+
+        // get the number of columns from schema
+        int num_columns = ((schema[1] & 0xFF) << 8) | (schema[0] & 0xFF);
+
+        // initialize the iterator for schema and type array for columns and also length of columns
+        int schema_iterator = 2;
+        int[] type_col = new int[num_columns];
+        String[] name_col = new String[num_columns];
+
+        // iterate over schema to fill type_col also get num of fixed and num of variable length columns
+        int fixed_col = 0;
+        int variable_col = 0;
+
+        for(int i = 0; i < num_columns; i++){
+            int offs = ((schema[schema_iterator+1] & 0xFF) << 8) | (schema[schema_iterator] & 0xFF);
+            type_col[i] = (schema[offs] & 0xFF);
+            int len_col = (schema[offs+1] & 0xFF);
+
+            byte[] temp = new byte[len_col];
+            System.arraycopy(schema, offs+2, temp, 0, len_col);
+
+            name_col[i] = new String(temp);
+
+            if(type_col[i] == 0){
+                variable_col++;
+            }
+            else if(type_col[i] == 1){
+                fixed_col++;
+            }
+            else if(type_col[i] == 2){
+                fixed_col++;
+            }
+            else if(type_col[i] == 3){
+                fixed_col++;
+            }
+            else{
+                fixed_col++;
+            }
+
+            schema_iterator += 2;
+        }
+
+        // find the column index which matches the column name
+        int idx = -1;
+        for(int i = 0; i < name_col.length; i++){
+            if(Objects.equals(name_col[i], column_name)){
+                idx = i;
+                break;
+            }
+        }
+        if(idx == -1){
+            throw new IllegalArgumentException("Column name does not match any of the columns");
+        }
+        int bl_id;
+        String index_file_name = table_name + "_" + column_name + "_index";
+
+        switch (type_col[idx]) {
+            case 0:
+                BPlusTreeIndexFile<String> bPT1 = new BPlusTreeIndexFile<>(order, String.class);
+
+                bl_id = 1;
+                while(get_data_block(table_name, bl_id) != null){
+                    List<Object[]> list_records = get_records_from_block(table_name, bl_id);
+                    for(int i = 0; i < list_records.size(); i++){
+                        if((list_records.get(i))[idx] != null){
+                            bPT1.insert((String)((list_records.get(i))[idx]), bl_id);
+                        }
+                    }
+                    bl_id++;
+                }
+                int index1 = this.getDb().addFile(bPT1);
+                file_to_fileid.put(index_file_name, index1);
+
+                break;
+            case 1:
+                BPlusTreeIndexFile<Integer> bPT2 = new BPlusTreeIndexFile<>(order, Integer.class);
+
+                bl_id = 1;
+                while(get_data_block(table_name, bl_id) != null){
+                    List<Object[]> list_records = get_records_from_block(table_name, bl_id);
+                    for(int i = 0; i < list_records.size(); i++){
+                        if((list_records.get(i))[idx] != null) {
+                            bPT2.insert((Integer) ((list_records.get(i))[idx]), bl_id);
+                        }
+                    }
+                    bl_id++;
+                }
+                int index2 = this.getDb().addFile(bPT2);
+                file_to_fileid.put(index_file_name, index2);
+
+                break;
+            case 2:
+                BPlusTreeIndexFile<Boolean> bPT3 = new BPlusTreeIndexFile<>(order, Boolean.class);
+                bl_id = 1;
+                while(get_data_block(table_name, bl_id) != null){
+                    List<Object[]> list_records = get_records_from_block(table_name, bl_id);
+                    for(int i = 0; i < list_records.size(); i++){
+                        if((list_records.get(i))[idx] != null){
+                            bPT3.insert((Boolean)((list_records.get(i))[idx]), bl_id);
+                        }
+                    }
+                    bl_id++;
+                }
+                int index3 = this.getDb().addFile(bPT3);
+                file_to_fileid.put(index_file_name, index3);
+
+                break;
+            case 3:
+                BPlusTreeIndexFile<Float> bPT4 = new BPlusTreeIndexFile<>(order, Float.class);
+                bl_id = 1;
+                while(get_data_block(table_name, bl_id) != null){
+                    List<Object[]> list_records = get_records_from_block(table_name, bl_id);
+                    for(int i = 0; i < list_records.size(); i++){
+                        if((list_records.get(i))[idx] != null){
+                            bPT4.insert((Float) ((list_records.get(i))[idx]), bl_id);
+                        }
+                    }
+                    bl_id++;
+                }
+                int index4 = this.getDb().addFile(bPT4);
+                file_to_fileid.put(index_file_name, index4);
+
+                break;
+            case 4:
+                BPlusTreeIndexFile<Double> bPT5 = new BPlusTreeIndexFile<>(order, Double.class);
+                bl_id = 1;
+                while(get_data_block(table_name, bl_id) != null){
+                    List<Object[]> list_records = get_records_from_block(table_name, bl_id);
+                    for(int i = 0; i < list_records.size(); i++){
+                        if((list_records.get(i))[idx] != null){
+                            bPT5.insert((Double) ((list_records.get(i))[idx]), bl_id);
+                        }
+                    }
+                    bl_id++;
+                }
+                int index5 = this.getDb().addFile(bPT5);
+                file_to_fileid.put(index_file_name, index5);
+
+                break;
+            default:
+                throw new IllegalArgumentException("Invalid value for variable");
+        }
+
+        return true;
     }
 
     // returns the block_id of the leaf node where the key is present
     public int search(String table_name, String column_name, RexLiteral value) {
         /* Write your code here */
-        return -1;
+        if(!check_index_exists(table_name, column_name)){
+            return -1;
+        }
+
+        String index_file_name = table_name + "_" + column_name + "_index";
+        int file_id = file_to_fileid.get(index_file_name);
+
+        return db.search_index(file_id, value);
     }
 
     public boolean delete(String table_name, String column_name, RexLiteral value) {
@@ -422,4 +730,4 @@ public class StorageManager {
         return null;
     }
 
-}
\ No newline at end of file
+}
diff --git a/in/ac/iitd/src/main/java/optimizer/rel/PIndexScan.java b/in/ac/iitd/src/main/java/optimizer/rel/PIndexScan.java
index db265b7..08698b8 100644
--- a/in/ac/iitd/src/main/java/optimizer/rel/PIndexScan.java
+++ b/in/ac/iitd/src/main/java/optimizer/rel/PIndexScan.java
@@ -1,16 +1,29 @@
 package optimizer.rel;
 
+import index.bplusTree.BPlusTreeIndexFile;
+import index.bplusTree.LeafNode;
 import org.apache.calcite.plan.RelOptCluster;
 import org.apache.calcite.plan.RelOptTable;
 import org.apache.calcite.plan.RelTraitSet;
 import org.apache.calcite.rel.RelNode;
+import org.apache.calcite.rel.core.Project;
 import org.apache.calcite.rel.core.TableScan;
 import org.apache.calcite.rel.type.RelDataType;
+import org.apache.calcite.rex.RexInputRef;
 import org.apache.calcite.rex.RexNode;
-
+import java.util.HashSet;
+import java.util.Set;
+import org.apache.calcite.rex.RexCall;
+import org.apache.calcite.rex.*;
 import manager.StorageManager;
+import org.apache.calcite.sql.SqlKind;
+import org.apache.calcite.sql.type.SqlTypeName;
+import storage.AbstractBlock;
+import storage.AbstractFile;
 
+import java.util.ArrayList;
 import java.util.List;
+import java.util.Objects;
 
 // Operator trigged when doing indexed scan
 // Matches SFW queries with indexed columns in the WHERE clause
@@ -48,13 +61,645 @@ public class PIndexScan extends TableScan implements PRel {
             return table.getQualifiedName().get(1);
         }
 
-        @Override
+        public int comparator(Object key1, Object key2) {
+        if (key1 instanceof Integer && key2 instanceof Integer) {
+            return Integer.compare((Integer) key1, (Integer) key2);
+        }
+        else if (key1 instanceof String && key2 instanceof String) {
+            return ((String) key1).compareTo((String) key2);
+        }
+        else if (key1 instanceof Boolean && key2 instanceof Boolean) {
+            return Boolean.compare((Boolean) key1, (Boolean) key2);
+        }
+        else if (key1 instanceof Float && key2 instanceof Float) {
+            return Float.compare((Float) key1, (Float) key2);
+        }
+        else if (key1 instanceof Double && key2 instanceof Double) {
+            return Double.compare((Double) key1, (Double) key2);
+        }
+        else {
+            throw new IllegalArgumentException("Unsupported key types");
+        }
+    }
+
+    public Object converter(byte[] bytes, Object value){
+
+        /* Write your code here */
+
+        if (value instanceof Integer) {
+            return convertBytesToInteger(bytes);
+        } else if (value instanceof String) {
+            return new String(bytes);
+        } else if (value instanceof Boolean) {
+            return convertBytesToBoolean(bytes);
+        } else if (value instanceof Float) {
+            return convertBytesToFloat(bytes);
+        } else if (value instanceof Double) {
+            return convertBytesToDouble(bytes);
+        } else {
+            throw new UnsupportedOperationException("Conversion for the specified type is not supported");
+        }
+    }
+
+    public Object convertBytesToInteger(byte[] bytes) {
+        validateBArrayLength(bytes, 4);
+        return ((bytes[0] << 24) | ((bytes[1] & 0xFF) << 16) | ((bytes[2] & 0xFF) << 8) | (bytes[3] & 0xFF));
+    }
+
+    public Object convertBytesToBoolean(byte[] bytes) {
+        validateBArrayLength(bytes, 1);
+        return (bytes[0] != 0);
+    }
+
+    public Object convertBytesToFloat(byte[] bytes) {
+        validateBArrayLength(bytes, 4);
+        return (Float.intBitsToFloat(byteArrayToFloat(bytes)));
+    }
+
+    public Object convertBytesToDouble(byte[] bytes) {
+        validateBArrayLength(bytes, 8);
+        return (Double.longBitsToDouble(byteArrayToLong(bytes)));
+    }
+
+    public void validateBArrayLength(byte[] bytes, int expectedLength) {
+        if (bytes.length != expectedLength) {
+            throw new IllegalArgumentException("Byte array length does not match the expected length for conversion");
+        }
+    }
+
+    public int byteArrayToFloat(byte[] bytes) {
+        return (bytes[0] << 24) | ((bytes[1] & 0xFF) << 16) | ((bytes[2] & 0xFF) << 8) | (bytes[3] & 0xFF);
+    }
+
+    public long byteArrayToLong(byte[] bytes) {
+        long value = 0;
+        for (int i = 0; i < bytes.length; i++) {
+            value |= ((long) (bytes[i] & 0xFF)) << (8 * (bytes.length-1-i)); //Doubt
+        }
+        return value;
+    }
+
+
+    @Override
         public List<Object[]> evaluate(StorageManager storage_manager) {
             String tableName = getTableName();
             System.out.println("Evaluating PIndexScan for table: " + tableName);
 
             /* Write your code here */
+            // for a given query of type SELECT * FROM $table_name WHERE $col_name = $value
+            // we have to implement this query
+            // we are given that for the given table and column, an index is already created (using B+ tree)
+            // you need to use function create_index which is specified below
+
+            // returns the block id of leaf node where the key is present
+//            public <T> int search_index(int file_id, T key){
+//                if(file_id >= files.size()){
+//                    return -1;
+//                }
+//                AbstractFile<? extends AbstractBlock> file = files.get(file_id);
+//                if(file instanceof BPlusTreeIndexFile){
+//                    return ((BPlusTreeIndexFile<T>) file).search(key);
+//                }
+//                return -1;
+//            }
+
+            // Using this function you need to get the block id of leaf node by searching the key in B+ tree
+            // then return the list of block ids of entries (of B+ tree) which match the given key
+
+//            String tableName = getTableName();
+//            System.out.println("Evaluating PIndexScan for table: " + tableName);
+            if (!storage_manager.check_file_exists(tableName)) {
+                return null;
+            }
+
+
+            List<Object[]> final_list = new ArrayList<>();
+
+    // Extract column name and value from the filter condition
+
+            // Get the file ID of the table
+            int file_id = storage_manager.convert_file_to_id(tableName);
+
+            // get the col_name from the schema of the file
+            byte[] schema_data = storage_manager.get_data_block(tableName, 0);
+
+            // get number of columns
+            int num_columns = ((schema_data[1]) << 8) | (schema_data[0] & 0xFF);
+
+            // initialize the iterator for schema and type array for columns and also length of columns
+            int schema_iterator = 2;
+            int[] type_col = new int[num_columns];
+            String[] name_col = new String[num_columns];
+
+            // iterate over schema to fill type_col also get num of fixed and num of variable length columns
+            int fixed_col = 0;
+            int variable_col = 0;
+
+            for(int i = 0; i < num_columns; i++){
+                int offs = ((schema_data[schema_iterator+1]) << 8) | (schema_data[schema_iterator] & 0xFF);
+                type_col[i] = (schema_data[offs] & 0xFF);
+                int len_col = (schema_data[offs+1] & 0xFF);
+
+                byte[] temp = new byte[len_col];
+                System.arraycopy(schema_data, offs+2, temp, 0, len_col);
+
+                name_col[i] = new String(temp);
+
+                if(type_col[i] == 0){
+                    variable_col++;
+                }
+                else if(type_col[i] == 1){
+                    fixed_col++;
+                }
+                else if(type_col[i] == 2){
+                    fixed_col++;
+                }
+                else if(type_col[i] == 3){
+                    fixed_col++;
+                }
+                else{
+                    fixed_col++;
+                }
+
+                schema_iterator += 2;
+            }
+
+            int columnName = -1;
+            Object value = null;
+            String operator = null;
+            String real_colname = null;
+
+            if (filter != null && filter instanceof RexCall) {
+                RexCall call = (RexCall) filter;
+                List<RexNode> operands = call.operands;
+                if (operands.size() == 2) {
+                    RexNode leftOperand = operands.get(0);
+                    RexNode rightOperand = operands.get(1);
+                    if (leftOperand instanceof RexInputRef && rightOperand instanceof RexLiteral) {
+                        // Extract column name
+                        columnName = ((RexInputRef) leftOperand).getIndex();
+
+                        // Extract value
+                        RexLiteral literal = (RexLiteral) rightOperand;
+                        value = literal.getValue();
+                        real_colname = rowType.getFieldList().get(columnName).getName();
+
+                        SqlTypeName typeName = rowType.getFieldList().get(columnName).getType().getSqlTypeName();
+                        switch (typeName) {
+                            case VARCHAR:
+                                value = literal.getValueAs(String.class);
+                                break;
+                            case INTEGER:
+                                value = literal.getValueAs(Integer.class);
+                                break;
+                            case BOOLEAN:
+                                value = literal.getValueAs(Boolean.class);
+                                break;
+                            case FLOAT:
+                                value = literal.getValueAs(Float.class);
+                                break;
+                            case DOUBLE:
+                                value = literal.getValueAs(Double.class);
+                                break;
+                            case DECIMAL:
+                                value = literal.getValueAs(Double.class);
+                                break;
+                            // Add cases for other supported types if needed
+                            default:
+                                throw new IllegalArgumentException("Unsupported data type");
+                                // Handle unsupported types
+                        }
+
+                        // Extract operator
+                        SqlKind opKind = call.getKind();
+                        operator = null;
+                        switch (opKind) {
+                            case EQUALS:
+                                operator = "=";
+                                break;
+                            case LESS_THAN:
+                                operator = "<";
+                                break;
+                            case GREATER_THAN:
+                                operator = ">";
+                                break;
+                            case LESS_THAN_OR_EQUAL:
+                                operator = "<=";
+                                break;
+                            case GREATER_THAN_OR_EQUAL:
+                                operator = ">=";
+                                break;
+                            // Add cases for other comparison operators if needed
+                            default:
+                                // Handle unsupported operators
+                                break;
+                        }
+                        // Now you have columnName, value, and operator
+                    }
+                }
+            }
+
+            if (columnName == -1 || value == null) {
+                return null;
+            }
+
+
+//            String real_colname = rowType.getFieldList().get(columnName);
+
+
+            // find the column index which matches the column name
+            int idx = -1;
+            for(int i = 0; i < name_col.length; i++){
+                if(Objects.equals(name_col[i], real_colname)){
+                    idx = i;
+                    break;
+                }
+            }
+            if(idx == -1){
+                throw new IllegalArgumentException("Column name does not match any of the columns");
+            }
+
+            if(Objects.equals(operator, "=")){
+                // Search for the value in the index
+                String index_file_name = tableName + "_" + real_colname + "_index";
+                int index_file_id = storage_manager.convert_file_to_id(index_file_name);
+
+                // store blocks in a set
+                Set<Integer> set_blocks = new HashSet<>();
+
+                // get the leaf node block
+                int block_id = storage_manager.getDb().search_index(index_file_id, value);
+                if (block_id == -1) {
+                    return final_list;
+                }
+
+                // initialize curr leaf id
+                int curr_leaf_id = block_id;
+
+                while(curr_leaf_id != 0){
+                    // get the leaf block data
+                    byte[] curr_leaf_block = storage_manager.get_data_block(index_file_name, curr_leaf_id);
+
+                    // get last offs
+                    int last_offs = ((curr_leaf_block[6] << 8)) | (curr_leaf_block[7] & 0xFF);
+
+                    // check if at least one key matches the value
+                    // take all that match into set_blocks and move to the right
+                    boolean check = true;
+
+                    // initialise start offs
+                    int start_offs = 8;
+
+                    while (start_offs < last_offs) {
+                        int curr_block = ((curr_leaf_block[start_offs] << 8)) | (curr_leaf_block[start_offs + 1] & 0xFF);
+                        start_offs += 2;
+
+                        int curr_len = ((curr_leaf_block[start_offs] << 8)) | (curr_leaf_block[start_offs + 1] & 0xFF);
+                        start_offs += 2;
+
+                        byte[] byte_key = new byte[curr_len];
+                        System.arraycopy(curr_leaf_block, start_offs, byte_key, 0, curr_len);
+
+                        Object key = converter(byte_key, value);
+                        if (comparator(key, value) == 0) {
+                            set_blocks.add(curr_block);
+                            check = false;
+                        }
+                        start_offs += curr_len;
+                    }
+                    if(check){
+                        break;
+                    }
+                    curr_leaf_id = ((curr_leaf_block[4] << 8)) | (curr_leaf_block[5] & 0xFF);
+                }
+
+                for (Integer element : set_blocks) {
+                    List<Object[]> l = storage_manager.get_records_from_block(tableName, element);
+                    for (int i = 0; i < l.size(); i++) {
+                        if(l.get(i)[idx] == null) continue;
+                        if (comparator(l.get(i)[idx], value) == 0) {
+                            final_list.add(l.get(i));
+                        }
+                    }
+                }
+                return final_list;
+
+            }
+
+            else if(Objects.equals(operator, "<")){
+                // Search for the value in the index
+                String index_file_name = tableName + "_" + real_colname + "_index";
+                int index_file_id = storage_manager.convert_file_to_id(index_file_name);
+
+                // store blocks in a set
+                Set<Integer> set_blocks = new HashSet<>();
+
+                // get the leaf node block
+                int block_id = storage_manager.getDb().search_index(index_file_id, value);
+                if (block_id == -1) {
+                    return final_list;
+                }
+
+                // initialize curr leaf id
+                int curr_leaf_id = block_id;
+
+                while(curr_leaf_id != 0) {
+                    // get the leaf block data
+                    byte[] curr_leaf_block = storage_manager.get_data_block(index_file_name, curr_leaf_id);
+
+                    // get last offs
+                    int last_offs = ((curr_leaf_block[6] << 8)) | (curr_leaf_block[7] & 0xFF);
+
+                    // initialise start offs
+                    int start_offs = 8;
+
+                    while (start_offs < last_offs) {
+                        int curr_block = ((curr_leaf_block[start_offs] << 8)) | (curr_leaf_block[start_offs + 1] & 0xFF);
+                        start_offs += 2;
+
+                        int curr_len = ((curr_leaf_block[start_offs] << 8)) | (curr_leaf_block[start_offs + 1] & 0xFF);
+                        start_offs += 2;
+
+                        byte[] byte_key = new byte[curr_len];
+                        System.arraycopy(curr_leaf_block, start_offs, byte_key, 0, curr_len);
+
+                        Object key = converter(byte_key, value);
+
+                        if (comparator(key, value) < 0) {
+                            set_blocks.add(curr_block);
+                        }
+                        start_offs += curr_len;
+                    }
+                    curr_leaf_id = ((curr_leaf_block[2] << 8)) | (curr_leaf_block[3] & 0xFF);
+                }
+
+                for (Integer element : set_blocks) {
+                    List<Object[]> l = storage_manager.get_records_from_block(tableName, element);
+                    for (int i = 0; i < l.size(); i++) {
+                        if(l.get(i)[idx] == null) continue;
+                        if (comparator(l.get(i)[idx], value) < 0) {
+                            final_list.add(l.get(i));
+                        }
+                    }
+                }
+                return final_list;
+            }
+            else if(Objects.equals(operator, ">")){
+                // Search for the value in the index
+                String index_file_name = tableName + "_" + real_colname + "_index";
+                int index_file_id = storage_manager.convert_file_to_id(index_file_name);
+
+                // store blocks in a set
+                Set<Integer> set_blocks = new HashSet<>();
+
+                // get the leaf node block
+                int block_id = storage_manager.getDb().search_index(index_file_id, value);
+                if (block_id == -1) {
+                    return final_list;
+                }
+
+                // initialize curr leaf id
+                int curr_leaf_id = block_id;
+
+                while(curr_leaf_id != 0){
+                    // get the leaf block data
+                    byte[] curr_leaf_block = storage_manager.get_data_block(index_file_name, curr_leaf_id);
+
+                    // get last offs
+                    int last_offs = ((curr_leaf_block[6] << 8)) | (curr_leaf_block[7] & 0xFF);
+
+                    // initialise start offs
+                    int start_offs = 8;
+
+                    while (start_offs < last_offs) {
+                        int curr_block = ((curr_leaf_block[start_offs] << 8) & 0xFF) | (curr_leaf_block[start_offs + 1] & 0xFF);
+                        start_offs += 2;
+
+                        int curr_len = ((curr_leaf_block[start_offs] << 8) & 0xFF) | (curr_leaf_block[start_offs + 1] & 0xFF);
+                        start_offs += 2;
+
+                        byte[] byte_key = new byte[curr_len];
+                        System.arraycopy(curr_leaf_block, start_offs, byte_key, 0, curr_len);
+
+                        Object key = converter(byte_key, value);
+                        if (comparator(key, value) > 0) {
+                            set_blocks.add(curr_block);
+                        }
+                        start_offs += curr_len;
+                    }
+                    curr_leaf_id = ((curr_leaf_block[4] << 8)) | (curr_leaf_block[5] & 0xFF);
+                }
+
+                for (Integer element : set_blocks) {
+                    List<Object[]> l = storage_manager.get_records_from_block(tableName, element);
+                    for (int i = 0; i < l.size(); i++) {
+                        if(l.get(i)[idx] == null) continue;
+                        if (comparator(l.get(i)[idx], value) > 0) {
+                            final_list.add(l.get(i));
+                        }
+                    }
+                }
+                return final_list;
+
+            }
+
+            else if(Objects.equals(operator, "<=")){
+                // Search for the value in the index
+                String index_file_name = tableName + "_" + real_colname + "_index";
+                int index_file_id = storage_manager.convert_file_to_id(index_file_name);
+
+                // store blocks in a set
+                Set<Integer> set_blocks = new HashSet<>();
+
+                // get the leaf node block
+                int block_id = storage_manager.getDb().search_index(index_file_id, value);
+                if (block_id == -1) {
+                    return final_list;
+                }
+
+                // initialize curr leaf id
+                int curr_leaf_id = block_id;
+
+                while(curr_leaf_id != 0){
+                    // get the leaf block data
+                    byte[] curr_leaf_block = storage_manager.get_data_block(index_file_name, curr_leaf_id);
+
+                    // get last offs
+                    int last_offs = ((curr_leaf_block[6] << 8)) | (curr_leaf_block[7] & 0xFF);
+
+                    // check if at least one key matches the value
+                    // take all that match into set_blocks and move to the right
+                    boolean check = true;
+
+                    // initialise start offs
+                    int start_offs = 8;
+
+                    while (start_offs < last_offs) {
+                        int curr_block = ((curr_leaf_block[start_offs] << 8)) | (curr_leaf_block[start_offs + 1] & 0xFF);
+                        start_offs += 2;
+
+                        int curr_len = ((curr_leaf_block[start_offs] << 8)) | (curr_leaf_block[start_offs + 1] & 0xFF);
+                        start_offs += 2;
+
+                        byte[] byte_key = new byte[curr_len];
+                        System.arraycopy(curr_leaf_block, start_offs, byte_key, 0, curr_len);
+
+                        Object key = converter(byte_key, value);
+                        if (comparator(key, value) == 0) {
+                            set_blocks.add(curr_block);
+                            check = false;
+                        }
+                        start_offs += curr_len;
+                    }
+                    if(check){
+                        break;
+                    }
+
+                    curr_leaf_id = ((curr_leaf_block[4] << 8)) | (curr_leaf_block[5] & 0xFF);
+                }
+
+//                for (Integer element : set_blocks) {
+//                    List<Object[]> l = storage_manager.get_records_from_block(tableName, element);
+//                    for (int i = 0; i < l.size(); i++) {
+//                        if (comparator(l.get(i)[idx], value) <= 0) {
+//                            final_list.add(l.get(i));
+//                        }
+//                    }
+//                }
+//                return final_list;
+
+
+                // Search for the value in the index
+//                String index_file_name = tableName + "_" + columnName + "_index";
+//                int index_file_id = storage_manager.convert_file_to_id(index_file_name);
+
+                // store blocks in a set
+//                Set<Integer> set_blocks = new HashSet<>();
+
+                // get the leaf node block
+//                int block_id = storage_manager.getDb().search_index(index_file_id, value);
+//                if (block_id != -1) {
+//                    return final_list;
+//                }
+
+                // initialize curr leaf id
+                curr_leaf_id = block_id;
+
+                while(curr_leaf_id != 0) {
+                    // get the leaf block data
+                    byte[] curr_leaf_block = storage_manager.get_data_block(index_file_name, curr_leaf_id);
+
+                    // get last offs
+                    int last_offs = ((curr_leaf_block[6] << 8)) | (curr_leaf_block[7] & 0xFF);
+
+                    // initialise start offs
+                    int start_offs = 8;
+
+                    while (start_offs < last_offs) {
+                        int curr_block = ((curr_leaf_block[start_offs] << 8)) | (curr_leaf_block[start_offs + 1] & 0xFF);
+                        start_offs += 2;
+
+                        int curr_len = ((curr_leaf_block[start_offs] << 8)) | (curr_leaf_block[start_offs + 1] & 0xFF);
+                        start_offs += 2;
+
+                        byte[] byte_key = new byte[curr_len];
+                        System.arraycopy(curr_leaf_block, start_offs, byte_key, 0, curr_len);
+
+                        Object key = converter(byte_key, value);
+                        if (comparator(key, value) <= 0) {
+                            set_blocks.add(curr_block);
+                        }
+                        start_offs += curr_len;
+                    }
+                    curr_leaf_id = ((curr_leaf_block[2] << 8)) | (curr_leaf_block[3] & 0xFF);
+                }
+
+                for (Integer element : set_blocks) {
+                    List<Object[]> l = storage_manager.get_records_from_block(tableName, element);
+                    for (int i = 0; i < l.size(); i++) {
+                        if(l.get(i)[idx] == null) continue;
+                        if (comparator(l.get(i)[idx], value) <= 0) {
+                            final_list.add(l.get(i));
+                        }
+                    }
+                }
+                return final_list;
+            }
+
+            else if(Objects.equals(operator, ">=")){
+                // Search for the value in the index
+                String index_file_name = tableName + "_" + real_colname + "_index";
+                int index_file_id = storage_manager.convert_file_to_id(index_file_name);
+
+                // store blocks in a set
+                Set<Integer> set_blocks = new HashSet<>();
+
+                // get the leaf node block
+                int block_id = storage_manager.getDb().search_index(index_file_id, value);
+                if (block_id == -1) {
+                    return final_list;
+                }
+
+                // initialize curr leaf id
+                int curr_leaf_id = block_id;
+
+                while(curr_leaf_id != 0){
+                    // get the leaf block data
+                    byte[] curr_leaf_block = storage_manager.get_data_block(index_file_name, curr_leaf_id);
+
+                    // get last offs
+                    int last_offs = ((curr_leaf_block[6] << 8)) | (curr_leaf_block[7] & 0xFF);
+
+                    // initialise start offs
+                    int start_offs = 8;
+
+                    while (start_offs < last_offs) {
+                        int curr_block = ((curr_leaf_block[start_offs] << 8)) | (curr_leaf_block[start_offs + 1] & 0xFF);
+                        start_offs += 2;
+
+                        int curr_len = ((curr_leaf_block[start_offs] << 8)) | (curr_leaf_block[start_offs + 1] & 0xFF);
+                        start_offs += 2;
+
+                        byte[] byte_key = new byte[curr_len];
+                        System.arraycopy(curr_leaf_block, start_offs, byte_key, 0, curr_len);
+
+                        Object key = converter(byte_key, value);
+                        if (comparator(key, value) >= 0) {
+                            set_blocks.add(curr_block);
+                        }
+                        start_offs += curr_len;
+                    }
+                    curr_leaf_id = ((curr_leaf_block[4] << 8)) | (curr_leaf_block[5] & 0xFF);
+                }
+
+                for (Integer element : set_blocks) {
+                    List<Object[]> l = storage_manager.get_records_from_block(tableName, element);
+                    for (int i = 0; i < l.size(); i++) {
+                        if(l.get(i)[idx] == null) continue;
+                        if (comparator(l.get(i)[idx], value) >= 0) {
+                            final_list.add(l.get(i));
+                        }
+                    }
+                }
+                return final_list;
+
+            }
+            else{
+                return null;
+            }
+
+
+            // If block_id is -1, key not found
+//            if (block_id != -1) {
+//                // Retrieve the block using block_id
+//                AbstractBlock block = storage_manager.get_block(tableName, block_id);
+//                if (block != null) {
+//                    // Return the list of entries in the block
+//                    return block.getEntries();
+//                }
+//            }
 
-            return null;
+            // Return null if the value is not found or if there's an error
+//            return null;
         }
-}
\ No newline at end of file
+}
